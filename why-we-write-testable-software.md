# Why we write testable software

The modern era has technology as the buzzword on everyone's lips. ðŸ‘„  There are apps to handle every single service one can think of. If an app can't do a job, there would be a device for performing the specific task. The analog world is getting replaced with a digital one. Its quite easy to indulge oneself in many third-rate apps which do a task but not upto satisfaction. Software developers are striving to get their product out to the market without bothering to think about whether it could prove worthwhile and whether is it good enough to retain customers. 

People are smart and they know which app is sub-par and does not deserve a place on their devices. If users try some app once or twice, it's not really helpful. What the product owners want is to have the customers keep using the application and that also gives satisfaction to the developers, knowing that there are people out there using the very items that they built with huge efforts. 

For any application to be a success, the first criteria would be to not have avoidable crashes and failures. That requires a robust testing mechanism which covers almost every aspect of the codebase and not rely only on external users feedback. Once external feedback mechanism starts, users expect quick turnaround and it could become overwhelming if the developers are not able to deliver quickly. The product owners want customers to be happy but don't speak the language that the developers converse in, after all it gets technical very quickly in a brainstorm.

It becomes a developer's job to understand where the customers are unsatisfied and what changes are required to be done to handle it. Developers need to speak the language of customers along with computers and should have the capability to translate one into another. That's where tests come into the picture. Tests can be termed as the spec sheet of the application. If one compiles a list of all the tests, they should be able to see what the application do without reading or understanding any of the code. There would definitely be a few solely technical tests required to prevent abrupt behaviour but all the positive behaviour should also be present.

Developers actually want ease of malleability in the software. Adding a new feature or tweaking an old one should be easy and should not require the developers to test out the whole architecture again. Tests help here very much. The only criteria that the developers get concerned with is whether every test is passing or not. Changing software can break some tests but those failures are also guides to fix the tests and get the software back up and running. Developers strive for not having to change a lot without having the confidence that their system is working. Tests give confidence and developing a simple software which has pretty much everything covered with tests is better than a complicated software without tests which get broken with every little change. 

Tests can be of multiple types. There are external frameworks which tests whether an app performs correctly or not and there are unit tests which tests whether any of the features are failing or not before external frameworks get their hands on the application. On the face, both of them can look to performing the same function, but there is a key difference between them. Unit tests have much smaller feedback loop than external frameworks. External user feedback has an even larger feedback loop. Clearly the best choice seem to be unit tests as it allows changing without breaking. 

It's not all shiny for unit tests also. Once a good enough test suite is compiled and ready to use, it becomes shiny but developing a robust suite takes time and developers have to begin by thinking the various ways that users can interact with a feature and eliminate all the negative cases before delivery. The aim of unit testing is ideally to reduce bugs faced by the users and getting the application appreciated for all the amazing tasks it can do. The software becomes ready for delivery as soon as all the old and new tests pass assuming the developers have been diligent enough to brainstorm the very many use cases. Some bugs would still pass through the cracks but many major ones would get caught in the nets.

Some developers are of the opinion that writing tests slows down software development and it may be rightly so. If someone is working on a small project with a couple of services, tests may seem to be an overkill. But when it comes to large distributed systems, tests prove to be fruitful in giving confidence that the other moving parts of the system are working perfectly. Large projects usually have version control checks that all the tests must be passing before it can be deployed. Imagine a developer working on a particular feature suddenly notices a feature worked by a team on the other side of the world is not working, it would be a pain to resolve but when there are enough tests present, there won't be any trouble of that sort. Some failures could require intervention from the other team but that's unavoidable in the real world.

The world is polarised and one can't help but notice the adverse components and still work how they want to do. I have made some arguments regarding the benefits of testing software here. If you feel that this seems like a good idea, give the next chapters a shot and see the ease with software can be developed without having to worry about a lot and maybe your opinion would be moved by the end of this book. I am not saying that follow test driven development as the only way, rather than a tool in your arsenal and use it in the places where you deem it fit.

Enough chitchat. Let's talk software.

